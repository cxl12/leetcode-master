# C++基础知识

## 语言基础

* 说一下C/C++ 中指针和引用的区别？
   1. 指针是存放对象地址的变量，可以不初始化，生命周期可以指向多个对象，有着自己的一块空间；
   2. 而引用只是对象的别名，必须初始化，生命周期内只能是一个对象的引用，不能改变引用关系，不能是NULL,不必分配内存。

* void*
  * 作用:可以指向任意type的指针

* 当i是一个整数的时候i++和++i那个更快？它们的区别是什么？
  * 几乎一样。i++返回的是i的值，需要用临时变量存储i值，++i返回的是i+1的值，即++i是一个确定的值，是一个可以修改的左值。

* 说一下static关键字的作用（腾讯）
   1. static修饰全局变量，静态全局变量存储在静态存储区中，在整个程序的生命周期内都一直存在，作用域是文件作用域，在本文件外不可见
   2. static修饰局部变量，静态局部变量存储在内存的静态存储区中，未初始化的静态全局变量会被默认初始化，在整个程序的生命周期内都一直存在，但是作用域仍然是局部作用域，当定义它的局部代码块结束了，它的作用域结束，但是一直保存在内存中，等相应的代码再次调用时可见，并且值没有发生改变。
   3. static修饰普通函数，函数定义为静态函数，静态函数只是在声明它的文件内可见，不能被其他文件使用，即只能在本cpp中使用。不要在头文件声明静态函数
   4. static修饰类的数据成员，变成静态数据成员，对多个类的对象而言，静态数据成员在内存中只有一份，由多个对象共享。
   5. static修饰类的成员函数，静态成员函数与静态数据成员一样，由多个对象共享，调用时可以直接类名.调用，函数内只能引用类的静态数据成员。

* 程序的编译过程？
  * C++是静态语言，需要编译后才能运行（从源文件到可执行文件）
  * 1 源文件经过预处理，去注释，展开宏定义，处理预编译指令，然后进行编译
  * 2 将预处理后的文件进行词法分析 语法分析 语义分析，代码优化，产生汇编代码文件或目标文件，汇编阶段把汇编代码翻译成目标文件（代码段 数据）
  * 3 在链接过程中将 =目标文件与引用到的库一起链接打包成可执行文件

* static 和 const 分别怎么用，类里面static和const可以同时修饰成员函数
  * const主要目的是取代宏定义等预编译指令，因为产生更小代码，而且编译器会提示错
    * 修饰普通函数的形参，限定参数只读，保护参数不被修改
    * 修饰类对象，只能调用const修饰的函数
    * 修饰类的成员函数，函数内不可以改变类的成员变量
    * 修饰指针时：顶层（*的右边）表示指针是常量，不能修改，在*的左边表示指针所指向的对象是常量
      * const char *p 表示 指向的内容不能改变。
      * char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。
  * 不可以同时用const和static修饰成员函数
    * const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*；但当一个成员为static的时候，该函数是没有this指针的，作用是表示该函数只作用在类型的静态变量上。也就是说此时const的用法和static是冲突的。

* 如何初始化const和static数据成员？
  * 通常在类外声明static成员，但是static const的整型（bool，char，int，long）可以在类中声明且初始化，static const的其他类型必须在类外初始化（包括整型数组）

* define 宏定义：在预处理阶段 预处理器只是完成替换和展开 没有进行计算工作

* vitual : 多态时候进行继承时 想在子类重载父类的函数使用的符号

* decltype : 让编译器自动推导表达式类型 应用场景:元编程

* volatile : 修饰全局变量，该值在程序控制外会被修改 告诉编译器不需要因为修改而去优化

* inline : 内联，必须与函数定义放在一起 一般放在头文件中 编译时 编译器会把函数代码副本放在每一个调用函数的地方 对于其他函数 都是运行时才被替代,类内定义的函数都是内联函数,必须与函数定义放在一起 <10行使用 防止多次调用栈空间 减少消耗内存，但是内联是否成功是由编译器决定的。

* 数据类型
    1. bool类型一个字节，起始只是占用了一个位
    2. char字符类型，占用一个字节
    3. short 短整型，占用两个字节
    4. int 整型，占用四个字节
    5. long 长整型，占八个字节
    6. float,单精度浮点型，占用4个字节
    7. double,双精度浮点型，占用8个字节

* 类型转换
  * 传统：type(expr)或者（type) expr;
    * 旧式的强制类型转换在表现形式上不会太清晰，容易看漏，出了错误追踪困难

  * 新标准：命名的强制类型转换： cast-name<type>(expr)，cast-name有四种：static_cast ,const_cast reinterpret_cast,dynamic_cast
    * static_cast:不包含底层const都可以使用，支持上行转换(派生类的指针或引用转为基类表示) 下行转换不安全，用于基本数据类型转

      * static_cast是相当于C的强制类型转换，用起来可能有一点危险，不提供运行时的检查来确保转换的安全性
        * 适用情景
          * 1：将一个较大的算术类型赋值给较小的类型，此时编译不再报警告
          * 适用情景2：应对编译器无法自动类型转换 ：如将void指针返回最初的类型状态，如double *p = static_cast<double>(p2);p2是个空指针(由double指针转换而来)  
  
      * const_cast,只能改变运算对象的底层const，去掉<指针或引用>的const或volatile，常量转为非常量，只有它可以修改常量属性，其他三个会使得编译器报错，只能修改常量属性，不能修改对象类型，否则编译器报错
        * char *p = const_cast<char *>(pc); //pc是const char *;但是不能通过p写值）

    * reinterpret_cast :底层转换不安全且不可移植,通常为运算对象的位模式提供低层次的解释。
      * 如int *ip; char *pc = reinterpret_cast<char*>(ip); //但是pc所指的真实对象是int,不能作为普通指针，否则可以造成运行时错

    * dynamic_cast<new_type>(old_expression)
      * 其他三种转换都是编译时完成 这个是运行时处理 会进行类型检查不能用于内置的基本数据类型的强制转换，<>里面必须是指针或引用，成功返回指针失败返回nullptr
        * 支持上行转换
        * 下行转换(比static_cast安全 会类型检查)，基类一定要有虚函数 否则不能通过编译

* 右值引用 / 左值引用 和 move语义

  * 左值和右值
    * 左值:可以求地址的变量 有实体存储在内存中，是一个对象的本身
    * 右值:存储在内存或CPU寄存器中 无法求地址，代表的是对象的值
      * 典型:赋值时生成的临时变量int a = 10; int && aa = a + 1;

    * 右值引用
      * 右值引用只能绑定临时对象 引用对象将要被销毁 / 该对象没有其他用户
      * 使用右值引用的代码可以自由的接管所引用对象的内容
      * 为什么要有右值引用
        * 为了获取和重用右值，比如移动语义

    * 移动语义:修改记录 而不是真的复制 通过move获得左值上的右值引用

* move语义
  * C++ 11带来了move语义，可以有效的提高STL的效率https://blog.csdn.net/liyongOFDM/article/details/7667942

```
#include <iostream>
 
using namespace std;
 
vector<int> doubleValues (const vector<int>& v)
{
    vector<int> new_values( v.size() );
    for (auto itr = new_values.begin(), end_itr = new_values.end(); itr != end_itr; ++itr )
    {
        new_values.push_back( 2 * *itr );
    }
    return new_values;
}
 
int main()
{
    vector<int> v;
    for ( int i = 0; i < 100; i++ )
    {
        v.push_back( i );
    }
    v = doubleValues( v );
}
```

* 调用函数doubleValues时是有两次复制的，一次是在函数返回时，因为local变量要被回收，所以需要 copy构造一个临时对象来返回，当返回这个临时对象后，又需要一次 copy赋值操作来赋值给v。你可能会说，不返回对象就可以啊，可以返回一个引用或者一个指针，但是要这样做就得分配内存，但是C++的一个设计目标就是尽量少分配内存。上述更糟糕之处在于，返回的临时对象使用完之后是会被销毁掉的。
  * 在内存中我们完全可以把临时对象的指针偷过来，而不去拷贝,可以用右值引用去获取这个临时对象
  * move语义可以使你在使用临时对象时避免拷贝，并且可以安全的使用临时对象里的资源。

* 区分左右值

```
int x;
int & getRef () 
{
        returnx;
}

//函数返回的是左值

int x;
int getVal ()
{
    return x;
}
getVal();
//函数返回的是右值
```

```
string getName ()
{
    return"Alex";
}
getName();
string nema = getName();

const
 string& name = getName(); // ok

 string& name = getName(); // NOT ok
```

* 分析
  * 对“Alex”进行隐式类型转换，转换为一个string的临时对象，然后拷贝构造给name变量
  * C++认为不管getName如何实现，如果你返回的是一个非const引用，说明你可能回去修改一个可能会消失（如果是一个临时变量的话）东西；另外，如果是返回一个const引用，确保了临时变量不会很快消失（ 不是很懂，不会很快消失，那多久会消失呢）

* C++11中，会让你可以绑定一个mutable右值引用，也就是说，一个值是否临时的，可以使用右值引用来检测，右值引用使用&&语法，可以是const也可以是非const的
  * 例子
    * const string&& name = getName(); // ok
    * string&& name = getName(); //ok

* 关于左值引用和右值引用，最重要的是，当你写一个函数，函数的参数是左值引用或者右值引用

```
printReference (constString& str)
{
        cout << str;
}
 
printReference (String&& str)
{
        cout << str;
}
```

* 第一个具有const引用的函数，可以接受任意的参数，不管是左值还是右值，不管这个左值或者右值易变或者不易变（if mutable）；
* 对于第二个函数，除了 mutable rvalue-references类型，其他的类型都可以，比如：
  * printReference("alex")
  * 右值引用版本的函数就像一个俱乐部的入口，只有临时变量才可以进入。

* move构造和move赋值操作符
  * 右值引用的一个用处是可以用来创建move构造函数和move赋值操作符，move构造和move赋值可以避免内存重新分配，因为我们已经有了一个临时变量了。
  * 把一个对象中的一个字段移动到另一个对象是什么意思？如果是一个原生类型，比如int，我们赋值就可以了，但是对于指针类型的处理比较有趣。我们不需要再分配和初始化一段内存，我们只需要把临时对象中的指针偷过来，然后让原始指针指向null即可，因为临时对象不再需要了，所以我们可以把它的指针拿过来用：

* move构造和copy构造相互重载了，如果是临时对象就会自动调用move构造，如果不是，就会调用copy构造。

* 那么为什么move构造中要把原始指针置为null呢？
  * 因为如果不置为null，那么临时变量消失时，会析构，释放自己的指针，还资源给os，那么新对象中的指针也就随之会被delete掉。所以需要把原始指针置为null，这样临时变量在析构时就找不到给自己分配的那块内存了，那块内存也就可以被新对象正常使用了。
  * 注意：这里的重载规则要求如果要调用move构造，那么一定要传一个临时变量，并且一定要是一个可以修改的临时变量，如果不能修改，那么临对象内的指针就不能置为null了，如果一个函数返回的是const类型，那么就不能调用move构造了

* strlen函数与sizeof的区别
  * strlen是C语言的函数，它用来计算指定字符串 str 的长度，但不包括结束字符（即 null 字符）。其原型如下面的代码所示：
    * size_t strlen(char const* str);
      * 返回值是一个无符号整型size_t
    * strlen(x)- strlen(y)>= 0 条件是永真
    * 而strlen不区分是数组还是指针，就读到\0为止返回长度。而且strlen是不把\0计入字符串的长度的

  * sizeof 是C++的一个运算符，获得保证能容纳实现所建立的最大对象的字节大小。参数可以是数组、指针、类型、对象、函数等。
    * sizeof求得的结果是存储该字符串的变量占用的空间大小，因而一定会包括'\0'
    * 总之，对于指针，sizeof操作符返回这个指针占的空间，一般是4个字节；而对于一个数组，sizeof返回这个数组所有元素占的总空间。char*与char[]容易混淆，一定要分清，而且char*="aaa"

* C++的内存分区
    1. 栈区：主要存放函数参数以及局部对象，由系统自动分配和释放
    2. 堆区：系统为程序分配的动态内存，由用户通过new/delete手动申请和释放动态内存对象，对象的生存周期由程序决定，忘记释放对象的堆内存会造成内存泄漏
    3. 静态存储区，存放静态变量

* 请回答一下数组和指针的区别？
    1. 指针是一个保存变量的地址，通过指针可以间接访问对象，通常用于动态的数据结构，通过malloc分配内存，通过free释放内存
    2. 数组是一个保存固定数量的同类数据的集合，可以直接随机访问数组的数据，通常用于保存固定数目且数据类型相同的元素，它是由编译器分配和释放内存的，数组名可以看作一个指向数组首个元素的地址。

* 请你回答一下野指针是什么？
  * 野指针就是未初始化的指针
  * 悬空指针
    * 指向一个已经被删除或未申请访问权限的内存区域的指针（通常是指向的对象已经被释放）

* 内存泄漏怎么产生的？如何避免？
    1. 内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用。
    2. 更广义的内存泄漏还包括未对系统资源的及时释放，比如句柄、socket等没有使用相应的函数释放掉，导致系统资源的浪费。
    3. 解决方法
       1. 养成良好的编码习惯和规范，记得及时释放掉内存或系统资源。
       2. 重载new和delete，以链表的形式自动管理分配的内存。
       3. 使用智能指针负责动态对象的内存的释放

* 为什么引入智能指针
  * 动态内存管理容易出错，如果忘记释放就会造成内存泄漏；或者还有指针引用内存的情况下释放了对象的内存，容易产生引用非法内存的指针。为了更安全使用动态内存，新的标准库提供智能指针来管理动态对象。智能指针的行为类似常规指针，重要的区别时它负责自动释放所指向的对象的内存，智能指针有四种：share_ptr,unique_ptr,weak_ptr,auto_ptr四种

* 介绍一下智能指针
    1. 智能指针有四种，share_ptr,unique_ptr,weak_ptr,auto_ptr四种
    2. share_ptr
       1. 共享指针，share_ptr类内部维护一个引用计数器，允许多个同类型的指针指向同一对象,当增加引用时（拷贝或者赋值操作）时，每个share_ptr记录对象的引用计数器+1，撤销引用（某个指针指向了其他资源或被析构函数和调用）引用计数就会-1.当引用计数变为0时，系统就会彻底的释放这个资源，否则析构函数只负责计数器-1操作
    3. unique_ptr
       1. 资源所有权独占的智能指针，某个时刻只有一个unique_ptr指向一个给定的对象，当该指针被销毁时对象也被销毁，一般情况下不支持拷贝和赋值操作，但可以调用release和reset将指针的所有权转移
    4. weak_ptr
       1. 一种不控制对象生存期的智能指针，作为弱引用，指向一个由shared_ptr管理的对象，不对内存进行管理，不增加/减少shared_ptr的引用值，一旦最后一个对象的shared_ptr被销毁，对象就被释放，weak_ptr也会被释放，是一种共享指针。解决shared_ptr互相引用形成环无法释放资源，能够检查到管理对象是否已经被释放 从而避免访问非法内存，通常情况下，weak_ptr与shared_ptr搭配使用，是shared_ptr的助手。（在weak_ptr类中有一个成员函数lock()，这个函数可以返回一个weak_ptr指针所指向的资源的shared_ptr。如果weak_ptr所指向的资源已经不存在了，lock函数返回一个“空”shared_ptr。因此我们可以使用lock函数判断weak_ptr所指向的资源是否被回收。）
    5. auto_ptr :
       1. 被销毁时自动删除所指的对象（目的是不让多个auto_ptr指向同一个对象），若通过赋值/复制构造函数，它们本身会变成空指针NULL,而复制的指针获取资源的唯一使用权，所以不能以auto_ptr作为函数返回值或者容器的元素，应使用unique_ptr

* 智能指针的引用计数如何确保线程安全 - RAII - 原子操作(atomic operation)
    1. RAII（Resource Acquisition Is Initialization资源分配即初始化）: RAII的本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来，从而确保在对象的生存期内资源始终有效，对象销毁时资源一定会被释放。这个机制主要使用C++语言的一个特性：创建对象时系统会调用constructor，接着控制对资源的访问使之在对象的生命周期内始终保持有效，释放对象时系统会调用destructor。借此，我们实际上把管理一份资源的责任托管给了一个对象
    2. 好处
       1. 不需要显式地释放资源。
       2. 对象所需的资源在其生命期内始终保持有效
    3. 原子操作:多个线程访问同一个全局资源 保证其他所有线程不在同一时间访问相同的资源 确保在同一时刻只有唯一的线程对该资源进行访问，
    4. 智能指针在引用计数上使用原子操作来保证线程安全，但是指针指向对象的读写没法保证安全 : 两个线程中智能指针引用计数可能同时++ -- 该操作不是原子性 引用计数就错了 - 解决:使用互斥锁对多线程读写同一个shared_ptr进行加锁操作

* 请你介绍一下C++的智能指针？（Bigo一面)
    1. 由于 C++ 语言没有自动内存回收机制，所以动态内存的管理容易出错，如果忘记释放内存会造成内存泄漏，如果释放了还有指针引用的内存，会产生指向非法内存的指针，使得指针悬空成为野指针。
    2. 智能指针是C++11 引入的，用于管理在堆上分配的动态内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。包含在头文件<memory>中，其中包括：shared_ptr,unique_ptr和weak_ptr。
    3. 最常用的是shared_ptr,是共享指针，它采用引用计数的方法，记录当前内存对象被多少个shared_ptr指针所引用，该引用计数的内存在堆上分配。每新增一个引用计数加1，当过期时引用计数减1。只有引用计数为0时，智能指针才会自动释放引用的内存资源。shared_ptr的一个最大的陷阱是循环相互引用，会导致堆内存无法正确释放，从而导致内存泄漏。
    4. weak_ptr: 为了解决shared_ptr互相引用形成无法释放内存资源，导致内存泄漏的问题，引入了weak_ptr弱指针,weak_ptr是一个不控制对象生存期的智能指针，作weak_ptr的构造函数不会修改引用计数的值从而不会对对象的内存进行管理，其类似一个普通指针，虽然不管理引用计数的共享内存，但是可以检测所管理的对象是否已经被释放，从而避免非法访问。
    5. unique_ptr : unique_ptr智能指针独占所指向对象的的堆内存，即同一时间只有一个unique_ptr指向一个给定的堆内存对象，当指针被销毁时对象也被销毁，内存被释放，一般情况下不支持拷贝和赋值操作，但是可以调用release和reset将指针的所有权转移给另一个unique_ptr。

* 内存泄漏怎么产生的？如何避免？
    1. 内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用。
    2. 更广义的内存泄漏还包括未对系统资源的及时释放，比如句柄、socket等没有使用相应的函数释放掉，导致系统资源的浪费。

* 说几个C++11的新特性
    1. auto：编译器自动类型推导
    2. nullptr：空指针常量
    3. 智能指针
    4. 范围forv  循环
    5. 原子操作- 多线程问题(可见性 原子性 顺序性)
       1. 引入.h <atomic.h> 如果在多线程环境下访问共享资源 可以通过原子操作 确保安全 避免使用锁 提高运行效率
       2. 可见性: 多线程并发访问共享资源 一个线程对共享变量修改 其他线程能够立即看到
       3. 原子性: 一个操作要么全部生效 要么全部不生效
       4. 顺序性: 按照代码逻辑来运行
    6. lambda(函数对象：函数指针 函数符 lambda函数)
       1. lambda:可调用的代码单元 理解为未命名的内联函数，主要是解决那些容器算法中限定了可接受的谓词数量，但需求大于可接受量，用lambda表达式可以解决这个问题
       2. 函数指针:
          1. bool f3(int x) {return x % 3 == 0;}
          2. int count = count_if(num.begin(),num.end(),f3);
       3. lambda函数:
          1. 形式：[copture list] (parameter list) -> return type {function bady}
          2. auto fun = [](int x) {return x % 3 == 0;}; //忽略了返回类型，会根据函数体返回值自动推导，否则返回void，调用方式：cout << f() <<endl;
          3. 原理:编译器把lambda表达式生成一个匿名类的匿名对象 并在类中重载函数调用运算符
    7. override 和 final 关键字
       1. 成员函数后可以用voerride修饰，规定了该函数时重写函数，如果函数原型与基类不符合，编译器会报错。
       2. 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错

* C和C++区别？
    1. C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）
    2. C++是个以C为基础，兼容C语言，由相关语言组成的联邦，同时支持过程编程，面向对象编程，泛型编程，STL库等，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

* const与#define的区别
    1. 编译器处理方式
       1. define – 在预处理阶段进行替换
       2. const – 在编译时确定其值
    2. 类型检查
       1. define – 无类型，不进行类型安全检查，可能会产生意想不到的错误
       2. const – 有数据类型，编译时会进行类型检查
    3. 内存空间
       1. define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大
       2. const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝
    4. 其他
       1. 在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
       2. 宏替换只作替换，不做计算，不做表达式求解。

* 32位，64位系统中，各种常用内置数据类型占用的字节数？
    1. char ：1个字节(固定)
    2. *(即指针变量): 4个字节(32位机的寻址空间是4个字节。同理64位编译器是8个字节)(变化*)
    3. short int : 2个字节(固定)
    4. int： 4个字节(固定)
    5. unsigned int : 4个字节(固定)
    6. float: 4个字节(固定)
    7. double: 8个字节(固定)
    8. long: 4个字节
    9. unsigned long: 4个字节(变化*,其实就是寻址控件的地址长度数值，64位是8个字节)
    10. long long: 8个字节(固定)

* 什么时候用到拷贝构造函数？
    1. 一个对象以值传递的方式传入函数体；
    2. b.一个对象以值传递的方式从函数返回；
    3. c.一个对象需要通过另外一个对象进行初始化。
    4. 自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率，如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝

* 深拷贝与浅拷贝的区别？
    1. 浅拷贝是没有重新分配资源，比如两个类对象指向同一份内存资源
    2. 深拷贝是，类的对象的拷贝过程中，资源重新分配，每个类对象都有自己版本的资源

* 深拷贝好还是浅拷贝好？
    1. 如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

* 什么是内存对齐？为什么要对齐？什么时候需要对齐？
    1. 定义：字节对齐（内存对齐）主要是根据编译器设定或者在特定系统环境下数据按一定的规则存取在内存中的位置
    2. 由于不同系统对数据存取的位置有着不同的要求，对齐规则也就会有些不同。在X86系统下，一般默认对齐为4的整数倍并作为自然对齐。如果一个int类型变量存储在3-7字节，则为了访问未对齐的内存，处理器需要作两次内存访问；然而，如果int类型变量放在1-4字节，对齐的内存访问仅需要一次访问，用空间换取时间，可以提高cpu的效率和性能。
    3. 内存对齐是看类型

* 结构体内存对齐问题？结构体/类大小的计算？
    1. 内存对齐问题：
       1. 每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。

* 结构体大小计算
         1. 规则1：结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）
         2. 规则2：在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。即最终占用字节数为成员类型中最大占用字节数的整数倍
         3. 由于结构体所占空间与其内部元素的类型有关，而且与不同类型元素的排列有关，因此在定义结构体时，在元素类型及数量确定之后，我们还应该注意一下其内部元素的定义顺序。 一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少
         4. ![结构体内存对齐原则](../photos/结构体内存对齐例3.png)
         5. ![结构体内存对齐原则](../photos/结构体内存对齐原则2.png)
         6. ![结构体内存对齐例子](../photos/内存对齐例子4.png)
         7. ![结构体内存对齐例子](../photos/内存对齐例子5.png)
         8. ![结构体内存对齐例子](../photos/内存对齐例子6.png)
         9. ![结构体内存对齐例子](../photos/内存对齐例子8.png)

* 类大小的计算
  1. 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数不占用类内存
  2. c++要求每个实例在内存中都有独一无二的地址，空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1
  3. 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
  4. static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
  5. 虚函数：要占用4个字节，有个虚函数表指针用来指定虚函数的虚拟函数表的入口地址。

* 计算类大小例子
  1. class A {};: sizeof(A) = 1;
  2. class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);
  3. class A { static int a; };: sizeof(A) = 1;
  4. class A { int a; };: sizeof(A) = 4;
  5. class A { static int a; int b; };: sizeof(A) = 4;
  6. 类中用static声明的成员变量不计算入类的大小中，因为static data不是实例的一部分。static的属于全局的，他不会占用类的存储，他有专门的地方存储 （全局变量区）

* 大端与小端的概念？各自的优势是什么？
  * 大端与小端是用来描述多字节数据在内存中的存放顺序，即字节序。大端（Big Endian）指低地址端存放高位字节，小端（Little Endian）是指低地址端存放低位字节。
  * 需要记住计算机是以字节为存储单位。
    * 为了方便记忆可把大端和小端称作高尾端和低尾端
      * eg：如果是高尾端模式一个字符串“11223344”把尾部“44”放在地址的高位，如果是地尾端模式，把“44”放在地址的低位。

  * 各自优势：
    * Big Endian：符号位的判定固定为第一个字节，容易判断正负。
    * Little Endian：长度为1，2，4字节的数，排列方式都是一样的，数据类型转换非常方便。

  * 举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：
       1. 1)大端模式：低地址 -----------------> 高地址  0x12 | 0x34 | 0x56 | 0x78
       2. 2)小端模式：低地址 ------------------> 高地址 0x78 | 0x56 | 0x34 | 0x12

* C++中*和&同时使用是什么意思?
  * template <class T> void InsertFront(Node<T>* & head, T item)
    * 上面一个函数的声明，其中第一个参数*和&分别是什么意思？head是个指针，前面为什么加个&
    * 本来“* head”代表的是传指针的，但是只能改变head指向的内容，而“* &head”意思是说head是传进来的指针的同名指针，就能既改变*head指向的内容，又能改变head这个指针

* C/C++中堆和栈的区别
  * 数据结构中的堆和栈
    * 像是装数据的桶或者箱子
    * 堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列

  * 内存分配中的堆和栈
    * 内存中的栈区处于相对较高的地址，以地址的增长方向为上的话，栈地址是向下增长的。栈中分配局部变量空间，堆区是向上增长的用于分配程序员申请的内存空间。另外还有静态区是分配静态变量，全局变量空间的。只读区是分配常量和程序代码空间的；以及其他一些分区

  * 区别：
    * 栈式系统自动分配的空间，速度快，堆是程序根据自己需要申请的空间，是new分配的内存，速度慢

* 深拷贝和浅拷贝
   1. 浅拷贝: 拷贝构造函数(使用默认) 两个变量指向同一个内存块
   2. 深拷贝: 有指针必须要深拷贝 会产生danling ptr /在heap区申请新的内存空间进行拷贝

* 内联函数和宏定义的区别?
  * 区别1
    * 宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率。
    * 内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。如果内联函数的函数体过大，编译器会自动把这个内联函数变成普通函数。
  * 区别2
    * 宏定义是在预处理的时候把所有的宏名用宏体来替换（简单替换）
    * 内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

* 内联函数与普通函数的区别
  1. 内联函数和普通函数的参数传递机制相同，但是编译器会在每处调用内联函数的地方将内联函数内容展开，这样既避免了函数调用的开销又没有宏机制的缺陷。

  2. 普通函数在被调用的时候，系统首先要到函数的入口地址去执行函数体，执行完成之后再回到函数调用的地方继续执行，函数始终只有一个复制。内联函数不需要寻址，当执行到内联函数的时候，将此函数展开，如果程序中有N次调用了内联函数则会有N次展开函数代码。

  3. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句。如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行。

* 溢出，越界，泄漏
    1. 溢出:要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出，
       1. 缓冲区溢出（栈溢出）
          1. 程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。
          2. 而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。

    2. 越界:指向系统申请一块内存后，使用时却超出申请范围越界，当造成内存泄漏的代码运行时，所带来的错误是无法避免的（修改了越界的部分数据），通常指的是数组越界

    3. 泄漏:这里泄漏通常是指堆内存泄漏，程序在申请内存后，无法释放已申请的内存空间，通常是是指使用malloc和new分配的内存没有释放

* C/C++中分配内存的方法
  * C语言中
    1. malloc 函数： void *malloc(unsigned int size)
       1. 在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。
    2. calloc 函数： void *calloc(unsigned int num, unsigned int size)
       1. 按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间,calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。
    3. realloc 函数： void *realloc(void *ptr, unsigned int size)
       1. 动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。 申请的内存空间不会进行初始化

  * C++中
    * new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。

* 当i是一个整数的时候i++和++i那个更快？它们的区别是什么？
几乎一样。i++返回的是i的值，需要用临时变量存储i值，++i返回的是i+1的值，即++i是一个确定的值，是一个可以修改的左值。

* vector的reserve和capacity的区别？
   1. reserve(size)用于让容器预留空间，避免再次分配内存,改变capacity但不改变size()；
   2. capacity()返回在重新进行分配以前所能容纳的元素数量。

* void*作用:可以指向任意type的指针 ： operator delete pass 就是void*

* new/delete  vs malloc/free - new / operator new - placement new区别
  * new/delete 是c++运算符 自动计算需要分配内存 类型安全 会调用构造析构函数，创建的对象会存储在堆内存中
    * new:先分配内存 再调用构造函数 内部是malloc
    * delete:先调用析构函数 再free内存 以上是无法重载的

  * malloc/free C标准库函数，需要手动计算字节数，不是类型安全，无法报错，存储的对象在自由存储区

  * operator new/delete 是new/delete的一个过程 重载是为了设计内存池(内存管理模块)
    * placement new : new(extra) operator new(size_t s, size_t extra)e.g. Rep *p = new(extra) Rep; // 分配Rep + extra内容 它只是operator new重载的一个版本 并不分配内存 只是返回指向已经分配好的某段内存的指针

  * new和malloc的区别。
       1. malloc是c的库函数，不会自动计算分配的内存，没有构造函数，创建的对象存储在自由存储区，malloc不能被重载，返回的是空指针类型void * ，需要强制类型转换成我们所需的类型
       2. new是C++运算符，会自动计算要分配的内存，类型安全，先执行构造函数，内部调用malloc分配堆内存，创建的对象存储在堆内存，new可以被重载，返回指定类型的指针,无须进行类型转换，故new是符合类型安全性的操作符
    * 使用new操作符来分配对象内存时会经历三个步骤：
      * 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象
      * 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值
      * 第三部：对象构造完成后，返回一个指向该对象的指针
    * 使用delete操作符来释放对象内存时会经历两个步骤：
      * 第一步：调用对象的析构函数
      * 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间
    * 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

* C++类中数据成员初始化顺序？
    1. 成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关
    2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
    3. 类中const成员常量必须在构造函数初始化列表中初始化。
    4. 类中static成员变量，只能在类外初始化(同一类的所有实例共享静态成员变量)。
    5. 初始化 顺序
       1. 基类的静态变量或全局变量
       2. 派生类的静态变量或全局变量
       3. 基类的成员变量
       4. 派生类的成员变量

* C++内存分布问题（深信服）
  * C++内存分为5个区域：
    * 栈stack: 存储程序运行过程中的局部变量，函数参数。存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了
    * 堆 heap ：由程序new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。
    * 静态存储区 （.bss段和.data段）:全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。
    * 常量存储区 （.rodata段） ：存放常量，不允许修改（通过非正当手段也可以修改）
    * 代码区 （.text段） ：
      * 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）

  * C++内存模型
    * 栈：主要存放函数参数以及局部对象，由系统自动分配和释放
    * 堆：系统为程序分配的动态内存，由用户通过new/delete手动申请和释放动态内存对象，对象的生存周期由程序决定，忘记释放对象的堆内存会造成内存泄漏
    * 静态存储区，存放静态变量，字符串常量

  * 内存布局
    * 空类:为了用来标志该对象，空类的长度是1字节
    * 只有虚函数的表，虚函数指针占4个字节
    * 单继承只有一个虚函数表
    * 多继承会有多个虚函数表
    * 如果普通菱形继承会有重复的两个虚函数表
    * 虚继承的虚函数表唯一

* 函数的调用过程(深信服)
  * 程序启动的时候会自动调用main函数
  * 其他函数必须由函数调用语句执行
  * 当一个函数被调用时，程序分支到该函数并执行其主体中的语句
    * 按照调用约定的传参（将参数复制到栈中）
      * 从右向左传参，通过内存栈区域传参
    * 保存返回地址
    * 流程转移到被调用函数
    * 保存上一层栈帧的地址
    * 开辟局部变量空间
    * 执行被调用函数的相关代码
    * 最终将返回值存放在寄存器中
    * 返回到调用方

* 大小端，字节序
  * 对于一个由2个字节组成的16位整数，在内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序。
  * 大端是高字节存放到内存的低地址
  * 小端是高字节存放到内存的高地址
  * 就比如32位整数0x12345678,最高有效字节为0x12
  * 小端：0x78存储在低字节处  0x12 0x34 0x56 0x78
  * 大端： 0x12存储在低字节部分
  * 大部分CPU都是使用小端模式，如arm，可以通过程序判断大小端
  * int a = 0x656667;
    int b = 0x61626364;
    char *p = (char*)&q;
    printf("%s\n",p);
    dcba dfg

* 为什么区分大小端
  * 在操作系统中，x86和一般的OS（如windows，FreeBSD,Linux）使用的是小端模式
  * 但比如Mac OS是大端模式

* 我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。

* 应用场景：
  * 1、不同端模式的处理器进行数据传递时必须要考虑端模式的不同
  * 2、在网络上传输数据时，由于数据传输的两端对应不同的硬件平台，采用的存储字节顺序可能不一致。所以在TCP/IP协议规定了在网络上必须采用网络字节顺序，也就是大端模式。对于char型数据只占一个字节，无所谓大端和小端。而对于非char类型数据，必须在数据发送到网络上之前将其转换成大端模式。接收网络数据时按符合接受主机的环境接收。

* 函数指针和指针函数的区别
  * 指针函数
    * 指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。
    * 形式：int *fun(int x,int y);
  * 函数指针
    * 函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。
    * int (*fun)(int x,int y);
    * 赋值：
      * fun = &Function；
      * fun = Function;
    * 调用：
      * x = (*fun)();
      * x = fun();

* 用类的空指针调用非虚成员函数和虚函数会有什么问题

```
class A {
private:
    int data;
public:
    void fun0() { }
    virtual void fun1(){ }
};

int main() {
    A *p = nullptr;
    p->fun0();
    p->fun1();
}
```

* 空指针调用非虚成员函数，若函数中没有需要解引用this的地方，函数运行不会出错，但是若用到this，因为this=nullptr，运行出错。
  * 因为非虚成员函数采用的是 静态编译，编译器会根据对象的静态类型去调用，编译器就会 找到静态类型A*，通过类名找到成非虚 成员函数 ，因此 p无论指向什么，都不会影响p的 静态 类型，只要p的静态类型定了，编译器就会根据这个静态类型 找到对应的函数地址，所以调用成功

* 空指针调用虚函数运行时会出错。
  * 用对象调用函数时会 隐式传递一个this指针作为参数给函数，如果函数内没有对this指针进行取地址操作，则不会 报错

* 空指针为什么无法调用虚函数
  * 虚函数的调用动态绑定的机制，当调用p的虚函数时，会根据p去找到实例a存放数据的那块内存，实例a的内存中放在最前面的是指向虚表的虚指针
  * 然后根据虚指针vptr找到类A的虚函数表（类A所有对象共享这一个虚函数表）
  * 查虚函数表，在虚函数表里找到虚函数fun1()的地址，再根据这个地址去找到对应的函数代码。
  * 如果现在p=NULL，无法根据p找到虚指针vptr，找不到虚指针就找不到虚表，虚函数的地址放在虚表里呢，虚表都找不到，就无法调用对应的虚函数。

* 内存对齐（字节对齐)
  * 操作系统下数据堆数据存储是有一定规则的，按照一定的 存取粒度进行存取数据，x86系统按照4个字节为粒度存取数据，
  * 如果一个int类型变量存储在3-7字节，则为了访问未对齐的内存，处理器需要作两次内存访问；然而，如果int累心变量放在1-4字节，对齐的内存访问仅需要一次访问，用空间换取时间，可以提高cpu的效率和性能。
  * 所以数据存进内存的时候也是按照规则进行存取的
    * 对于结构体和类
      * 空的结构体需要有1字节大小，用于区分
      * 每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）
      * 经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。即最终占用字节数为成员类型中最大占用字节数的整数倍

* 字节对齐，对于一个struct，成员变量依次为：char,short,int,char，请问在32位系统和64位系统分别占多少个字节？
  * 区别在于long/unsigned long(4/8),指针(4/8)
  * 32位：
    * 12
  * 64位
    * 12

* 有一个1G内存的电脑，装了一个操作系统，在编程时，用malloc申请一个2G的空间能不能申请成功(深信服)
  * malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。程序运行时，堆空间只是程序向操作系统申请划出来的一大块虚拟地址空间。应用程序通过malloc申请空间，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。
  * 本题要申请空间的大小为 1.2G=2^30 × 1.2 Byte ，转换为十六进制约为 4CCC CCCC ，这个数值已经超过了 int 类型的表示范围，但还在 unsigned 的表示范围。幸运的是 malloc 函数要求的参数为 unsigned

* 内存重复释放，double free是指什么意思，有什么后果？
  * 同一个指针指向的内存被free两次，第二次free会访问到非法内存，因为第一次free后，该内存已经被释放，不属于当前的指针。

* linux下，堆内存的管理
  * linux下堆分配器主要由两个结构管理堆内存，一种是堆块头部形成的隐式链表，另一种是管理空闲堆块的显式链表（Glibc中的bins数据结构）
  * free函数在释放堆块时，会通过隐式链表判断相邻前、后堆块是否为空闲堆块；如果堆块为空闲就会进行合并，然后利用Unlink机制将该空闲堆块从Unsorted bin中取下。如果用户精心构造的假堆块被Unlink，很容易导致一次固定地址写，然后转换为任意地址读写，从而控制程序的执行。

* linux free函数的原理
  * 由堆块头部形成的隐式链表可知，一个需释放堆块相邻的堆块有两个：前一个块（由当前块头指针加pre_size确定），后一个块（由当前块头指针加size确定）。从而，在合并堆块时会存在两种情况：向后合并、向前合并。当前一个块和当前块合并时，叫做向后合并。当后一个块和当前块合并时，叫做向前合并。

* memcmp函数能不能用？为什么？
  * 不能，有字节对齐的机制，里面是乱码
  * 想用怎么办？
    * 两个办法
      * 把字节对齐的机制取消
      * 把整个内存初始化一遍，全部清零，再赋值

* 为什么C++支持函数重载而C语言不支持？
  * 一个函数在C++中能够被重载，但是在C语言确不能被重载的，是由于函数名在内存中存储方式不同所导致的。
  * 在C语言中，编译器区分一个函数，仅仅是靠 “_” + 函数名来区分的，如果我们将三个函数写成同名函数呢：编译器看来都是_fun,当出现第二个时，编译发现这个函数名已存在，便出现重定义编译失败
  * 一个函数在C++中的符号总是以?函数名@@YA开头，之后是H或者D，最后是以@Z结尾，共三部分。我们在仔细看会发现，在第二部分中H表示int ，D表示char，且第一个表示返回值，之后的表示函数的参数,尽管函数名相同，但只要是参数不同，在编译器看来也是不同的标识符：函数名相同，但编译器还是能够区分的。
  * 虽然在两个语言中， 函数的调用约定都是_cdecl，但是由于函数在内存中的存储方式不相同，C语言是“_” + 函数名形式，而C++是?函数名@@YA返回值 参数@Z形式，导致C++支持重载，而C语言不支持重载

* virtual
  * 实现基类子类多态化，基于向上类型转换，基类通过虚函数可以对多个子类相似的功能实现多态实现管理。

* volatile
  * 作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值.简单地说就是防止编译器对代码进行优化



## 部分库函数代码

* 编写一个有构造函数，析构函数，赋值函数，和拷贝构造函数的String类
  * string底层使用的是char * 字符数组去存储字符串

```
//.h
class String
{
  public:
    String(const char* str);
    String(const String &other);
    ~String();
    String & operate=(const String &other);
  private:
    char *m_data;
}
//.cpp
//构造函数1
String::String(const char *str)
{
  //如果还没有初始化
  if(str == nullptr)
  {
    m_data = new char[1];
    *m_data = '\0';
  }
  //已经初始化则覆盖
  else
  {
    int length = strlen(str);
    m_data = new char[length+1];
    strcpy(m_data,str);
  }
}

String::String(const String &other)
{
  int length = strlen(ohter.m_data);
  m_data = new char[length+1];
  strcpy(m_data,other.m_data);
}

//析构函数
String::~String()
{
  delete []m_data;
}

//重载赋值运算符
String::String& operator=(const String &other)
{
  //判断是否是自己为自己赋值
  if(&other==*this) return *this;
  delete []m_data;
  int length = strlen(other.m_data);
  m_data = new char[length+1];
  strcpy(m_data,ohter.m_data);
  return *this;
}
```

* 写出完整版的strcpy函数?

```
//对源字符串加const,表明其为输入参数 +2分
char *strcpy(char *strDest, const char *strSrc)
{
  assert((strDest != NULL) && (strSrc != NULL)); //对源地址和目的地址加非空断言 +3分
  char *address = strDest;
  while((*strDest++ = *strSrc++) != '\0');
  return address; //实现链式操作，返回目的地址 +3分
}
```

* 改进
  * 参数num控制拷贝的长度

```
char *strncpy(char *dest,const char *source)
{
    if(dest == NULL || source == NULL)
    {
        throw "pointer error";
    }
    char  *ptemp = dest;
    while((*destinatio++ = *source++) && num)
        num--;
    //有剩余长度
    if(num)
    {
        while(n--)
            *destination++ = '\0';
    }
    return pTemp;
}
```

* 实现memcpy

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char buf[100] = "abcdefghijk";
    //memcpy(buf+2, buf, 5);
    Memcpy(buf+2, buf, 5);
    printf("%s\n", buf+2);
}

void * my_memcpy(void *dst, const void *src, int n)
{
    if(!dst || !src || n <= 0)
        return NULL;
    //类型转换
    char* pdst = (char*) dst;
    char* psrc = (char*) src;
    //自后向前拷，内存对齐，src，dst的地址是不对齐的，读写效率变低
    //dest和source中的区域不能重叠，否则会出现未知结果中
    if(pdst > psrc && pdst < psrc+n)
    {
        pdst = pdst + n -1;
        psrc = psrc + n -1;
        while(n--)
            *pdst-- = *psrc--;
    }
    else
    {
        while(n--)
            *pdst++ = *psrc++;
    }
}
```

* 分析下面代码有什么问题？
  * string在c++是标准库类型，会造成变量名冲突
  * str1本身有11个字节，加上结束符\0需要12个字节，而数组只有10个字节大小，拷贝时会被发生数组越界的问题

```
void test1()
{
 char string[10];
 char* str1 = "01234567891";
 strcpy( string, str1 );
}
```

* 分析下面代码有什么问题？
  * string在c++是标准库类型，会造成变量名冲突
  * 数组名str1为是一个指针常量，不能被赋值
  * strcpy函数的字符串复制是只有遇到\0才停止，而str1中没有\0，所以复制的长度不确定。

```
void test2()
{
 char string[10], str1[10];
 int i;
 for(i=0; i<10; i++)
 {
 str1  = 'a';
 }
strcpy( string, str1 );
}
```

* 指出下面代码有什么问题？
  * string在c++是标准库类型，会造成变量名冲突
  * str1未统计结束符\0，长度不确定，可能会造成生数组越界的问题，应该把if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)

```
void test3(char* str1)
{
 if(str1 == NULL){
        return ;
 }
 char string[10];
 if( strlen( str1 ) <= 10 )
 {
 strcpy( string, str1 );
 }
}
```

* 检查下面代码有什么问题？
  * 传入GetMemory函数的形参时字符串指针，调用时是值传递，函数内修改的是形参，执行完后的str实参仍然是NULL
  * 函数内有用malloc申请动态内存,但是没有free释放内存，造成内存泄漏
  * printf函数格式错了，应该是格式化输出printf("%s",str);

```
void GetMemory( char *p )
{
 p = (char *) malloc( 100 );
}
void Test( void )
{
 char *str = NULL;
 GetMemory( str );
 strcpy( str, "hello world" );
 printf( str );
}
```

* 下面代码会出现什么问题？
  * GetMemory函数缺少判断是否申请成功
  * 函数内有用malloc申请动态内存,但是没有free释放内存，造成内存泄漏
  * printf函数格式错了，应该是格式化输出printf("%s",str);

```
void GetMemory( char **p, int num )
{
 *p = (char *) malloc( num ) ;
}
void Test( void )
{
 char *str = NULL;
 GetMemory( &str, 100 );
 strcpy( str, "hello" );
 printf( str );
}
```

* 下面代码会出现什么问题？
  * 未进行内存是否申请成功的判断
  * 在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：  
str = NULL;

void Test( void )
{
 char *str = (char *) malloc( 100 );
 strcpy( str, "hello" );
 free( str );
 ... //省略的其它语句
}

* 看看下面的一段程序有什么错误?
  * 缺少函数返回值
  * 指针p指针没有初始化，是个无效指针，访问无效指针会导致严重错误，而且编译器不会检查这个错误

```
swap( int* p1,int* p2 )
{
 int *p;
 *p = *p1;
 *p1 = *p2;
 *p2 = *p;
}
```

* 分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var
  * BOOL型变量：if(!var)
  * int型变量： if(var==0)
  * float型变量：
  * const float EPSINON = 0.00001;
  * if ((x >= - EPSINON) && (x <= EPSINON)
  * 指针变量：　　if(var==NULL)

* 以下为Windows NT下的32位C++程序，请计算sizeof的值
  * 函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
  * 不作为形参时：sizeof对数组，得到整个数组所占空间大小。

```
void Func ( char str[100] )
{
 sizeof( str ) = ? //4字节
}
void *p = malloc( 100 );
sizeof ( p ) = ? //4字节
```

* 宏定义
  * 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个
    * #define MIN(A,B) ((A) <= (B) ? (A) : (B));
  * 当你写下面的代码时会发生什么事？ least = MIN(*p++, b);
    * 在宏展开的时候对“参数”进行的是一对一的替换,((*p++) <= (b) ? (*p++) : (b)) ,会进行两次++自增操作，所以会产生宏的副作用

* 条件编译
  * 为什么标志头文件都有类似一下的结构
    * 头文件的编译宏的作用 是防止被宏保护的代码不被重复引用
    * c++支持函数重载，而c不支持函数重载，为了实现c和c++的混合编程，c++提供了c链接交换指定符号extern "C" 来解决名字匹配问题，函数申明加上xtern "C"，编译器会按照c语言的方式编译，c就可以调用c++的函数

```
#ifndef __INCvxWorksh
#define __INCvxWorksh
#ifdef __cplusplus
extern "C" {
#endif
/*...*/
#ifdef __cplusplus
}
#endif
#endif /* __INCvxWorksh */
```

* 编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来“abcdefghi”如果n=2，移位后应该是“hiabcdefg” 函数头是这样的：
//pStr是指向以'\0'结尾的字符串的指针
//steps是要求移动的n
void LoopMove ( char * pStr, int steps )
{
 //请填充...
}

* 解法1：使用strcpy(char* dest, const char *src)
  * 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间

```
void LoopMove(char *pStr, int steps)
{
  if( !pStr || steps <= 0)
    return;
  //先获取字符串长度
  int len = strlen(pStr);
  //判断steps是否移动次数是长度的倍数，这是不用字符串不变
  if(st == 0 || len == 0)
    return;
  //用临时字符数组中转
  char temp[len+1];
  strcpy(temp,pStr+len-st);
  strcpy(temp+st,PStr);
  *(temp+len) = '\0';
  strcpy(pStr,temp);
}
```

* 解法2
  * void *memcpy(void *dest, const void *src, size_t n);
    * 从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中

```
void LoopMove(char *pStr, int steps)
{
  if( !pStr || steps <= 0)
    return;
  //先获取字符串长度
  int len = strlen(pStr);
  //判断steps是否移动次数是长度的倍数，这是不用字符串不变
  if(st == 0 || len == 0)
    return;
  //用临时字符数组中转
  char temp[len+1];
  memery(temp,pStr+len-st,st);
  memory(temp,PStr,pStr,len-st);
  memory(pStr,temp,len);
}
```

## STL

* 迭代器的概念？
  * 扮演容器与算法间的胶合剂，是一种泛型指针，STL容器都附带自己专属的迭代器 只有容器设计者才知道如何设计迭代器，原生指针也是迭代器（设计模式一种）

* STL的组成
  * STL是一个容器类库，有六大组件
    * 容器
      * 顺序容器
        * vector
        * string
        * array
        * list
        * forward_list
        * deque
      * 关联容器
        * 有序关联容器
          * map
          * mutilmap
          * set
          * mutilset
        * 无序关联容器
          * unordered_map
          * unordered_set
          * unordered_mutilmap
          * unordered_mutilset
    * 为容器提供的算法
      * 70多个算法，包括查找算法、排序算法、消除算法、计数算法、比较算法、变换算法
    * 迭代器
      * 容器和算法之间的胶合剂。
    * 函数对象（仿函数）：重载（）运算符的成员函数，成为函数对象类，像调用函数一样调用对象
    * 适配器
      * stack， queue  priority_queue
    * 内存分配器
      * 隐藏在所有容器中，负责完成内存分配与释放，对象构造和析构的工作

* 容器适配器概述？
    1. 容器适配器是以既有容器作为底层,通过修改容器等操作完成自己的工作，一个适配器就是一种机制,接收一种已有的容器类型,使其成为相应的不同的目的类型，有stack,queue priority_queue
    2. stack是栈，元素是按照先进后出的原则存储，底层默认为deque容器，后进后出
    3. queue是队列，元素是先进先出，底层默认为deque容器
    4. priority_queue是优先队列，元素按照优先权存储，优先级高的先出，默认使用vector作为底层容器
    5. priority_queue
       1. 元素由各种优先权，优先权基于程序员设置的排序准则（默认为<），新加入元素会在所有优先级比它低的元素之前，如果有多个则同一优先权的元素无序
       2. 以底层vector容器为依据,根据堆的处理规则调整元素间位置
       3. 根据堆特性 优先队列实现取出最大最小的元素时间复杂度O(1) 对于插入和删除 最坏情况O(lgN)
       4. 如饭店的排队顺序是按照预定时间而不是到店时间。

* 什么是配置器，为什么有配置器？
   1. allocator是STL的重要组成，隐藏在所有容器中，负责完成内存分配与释放，对象构造和析构的工作。 从实现角度看 配置器实现了动态空间配置 空间管理
   2. 原因
      1. 小块内存带来的内存碎片问题
      2. 单从分配的角度来看。由于频繁分配、释放小块内存容易在堆中造成外碎片
      3. 2、小块内存频繁申请释放带来的性能问题
      4. 开辟空间,alloc找一块空闲块给用户，找空闲块也是需要时间的，尤其是在外碎片比较多的情况下。如果分配器其找不到，就要考虑处理假碎片现象(释放的小块空间没有合并)，需要将空闲内存块进行合并 需要时间

* 仿函数
  * 行为类函数 是一种重载的operator()的class，它像函数一样调用。仿函数（functors）在C++标准中采用的名称是函数对象（function objects）。仿函数主要用于STL中的算法中，满足STL对抽象性的要求，也和STL其他组件搭配，产生更灵活变化。仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象

```
原来普通函数的形式
 bool LengthIsLessThanFive(const string& str) {
      return str.length()<5;
 }
 int res=count_if(vec.begin(), vec.end(), LengthIsLessThanFive);

 //仿函数
class ShorterThan {
     public:
         explicit ShorterThan(int maxLength) : length(maxLength) {}
         bool operator() (const string& str) const {
             return str.length() < length;
         }
     private:
         const int length;
 };

count_if(myVector.begin(), myVector.end(), ShorterThan(length));//直接调用即可
```

### 顺序容器

* 常用容器及其底层实现
  * 顺序容器是一种有序元素的集合，每个元素按照插入的时机和位置有序，提供快速访问元素的能力，除了array外都提供高效和灵活的内存管理机制

  * 主要分为6种顺序容器：array,vector,deque,list,forward_list,string

    * array容器的底层是一个固定大小的数组，在建立array容器时需要指定大小，它提供快速的随机访问能力，相对于内置数组更加安全，容易使用
  
    * vector是个可变大小的容器，提供快速随机访问能力，但是在尾部之外的地方插入元素比较慢，因为底层是个动态数组，元素存储在连续的内存空间中，在中间插入数据，需要从插入位置整体后移，如果空间不足则默认以2倍大小申请更大的连续空间，将容器中的元素拷贝到新的内存中

    * list 底层是双向链表，不提供随机访问，只支持双向顺序访问，可以在任意位置插入元素，支持快速的增删

    * forward_list 底层是单向链表，只支持单向顺序访问，查询慢增删快

    * deque是双向队列，结合了list和vector各自的优点，一是支持快速随机访问，在首尾插入/删除数据都快，在中间插入/删除元素比较慢；二是没有容量的概念，是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接。底层是中央控制器 + 多个缓冲区，中央控制器是一个名为map的动态数组，存储一段段等长的名为缓冲区的连续空间的首地址（512个字节大小），缓冲区中存储元素，以分段的缓冲区组合成逻辑上整体连续的存储空间。

    * string 底层是动态数组，与vector类似，专门用于处理字符串操作

* vector越界访问会怎样？
  * 编译运行时会指向first + 对应下标的地址��值，访问到非法内存

* vector实现机制？
  * vector底层是一个动态数组，里面有一个指针指向一片内存区 当空间不够 会自动申请更大的空间 把原来的数据拷贝到新的连续空间，再释放原来空间，当删除vector元素，空间不释放 只是清空数据

* vector自增长机制？
   1. 当已经分配空间不够 分配两倍于原来空间内存 把当前的值拷贝到新分配的内存中，并释放原来的内存
   2. 在 VS 下是 1.5倍，在 GCC 下是 2 倍
      1. 空间和时间的权衡。
      2. 太小会频繁地申请空间，太大会造成浪费
      3. 简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。具体参见算法导论中，平摊分析那一章关于动态表扩张的分析。

* vector内存用完 如何动态扩展内存 释放内�� clear可以释放? 是否线程安全？
   1. vector用完当前内存后，以当前内存大小的2倍重新申请内存，把原来的元素复制过去，把新元素插上，然后释放原来内存，一般释放vector元素使用clear，但不是真正地释放内存，只是清空，要想释放内存使用swap，STL库允许多个线程读同一个容器 但STL库不会自动保证线程安全 需要自己去写多线程安全操作

* vector中begin和end函数返回的是什么？
   1. begin返回第一个元素迭代器
   2. end返回最后一个元素后面位置迭代器（尾迭代器）

* 为什么vector的插入操作可能会导致迭代器失效？
   1. 当vector的空间不足时，是动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效

* vector每次insert或erase之后，以前保存的iterator会不会失效？
   1. 理论上会失效，每次insert或erase后所有迭代器就重新计算，所以都可以看作会失效，原则上不能使用过期内存，但是vector底层是数组实现，要分情况考虑
   2. 1.假设insert位置在p 分两种情况
      1. 容器还有空余空间 不重新分配 那么p之前的迭代器都有效 p之后迭代器失效
      2. 容器重新分配内存 那么p位置前后的迭代器无效
   3. erase时 假设erase位置在p 则p之前迭代器都有效并且p指向下一个元素位置 p后面的迭代器无效

* auto_ptr可以做vector的元素呢？为什么？
   1. 不可以 STL规定容器的元素必须是可以拷贝构造和可被转移赋值 ，但是auto_ptr不能，当拷贝auto_ptr时会释放原来的指针，要用shared_ptr智能指针替代

* list/vector何时使用？
    1. vector适合对象简单 数量变化不大 随机访问频繁
    2. list适合对象大 对象数量变化频繁 插入删除频繁

* list的功能方法？
    1. 有两种list: list不提供随机访问，只支持双向顺序访问，可以在任意位置插入元素；forward_list是单向链表，只能单向顺序访问。
    2. assign : 允许从一个不同但相容的类型赋值，或者从容器的一个子序列赋值
    3. insert : 根据迭代器，在指定的位置插入元素
    4. erase : 根据迭代器，删除指定元素，返回下一个元素的迭代器
    5. clear ：清空容器

* list底层存储机制？
    1. 以node结点为单位存放数据 Node地址在内存中不一定连续 每次插入或删除一个元素 就创建和释放一个node结点

* List自带排序函数的排序原理？
    1. 归并排序中，时间复杂度是对数复杂度O(NlogN)

* vector与list在删除和插入方面的区别？
    1. vector如果在容器中间插入/删除 需要将插入位置后面的元素往后移动， 如果vector存储对象很大 或者构造函数很复杂则时间空间开销大，如果是简单对象则效率>list
    2. list 插入删除 需要对现有数据进行顺序遍历找到相应位置,然后直接删除，将删除位置前后链接起来
    3. 对象大，数量多，增删多就采用list,对象简单，数量少且稳定，查找多就采用vector，一样多采用vector

* deque底层实现机制？
    1. deque是双向队列，底层是中央控制器 + 多个缓冲区，中央控制器是一个名为map的动态数组，存储一段段等长的名为缓冲区的连续空间的首地址，缓冲区中是512字节的连续空间，存储元素，以分段的缓冲区组合成逻辑上整体连续的存储空间。deque动态以分段连续空间组合而成 随时可以增加一段新的连续空间并链接起来 不提供空间保留功能
    2. deque先用一段小的连续空间（名为map的动态数组）顺序存放了一个一个指针，然后这些顺序存放的指针再各自指向用来真正存放数据的512字节连续性空间。当Map指向的这块空间不够存放内存指针的时候，就会另觅一块更大的连续性空间（是map空间重新寻找，而不是缓冲区重新寻找），然后把指针一个一个复制过去，并销毁旧的空间（销毁的是原来的map空间）。利用这种数据结构，deque就能方便地模拟自身的存储区是连续性空间的假象，并且可以实现双向插入删除的功能

* deque的迭代器？
    1. 在迭代器中需要定义：当前元素的指针cur，当前元素所在缓冲区的起始指针first，当前元素所在缓冲区的尾指针last，指向map中指向所在缓区地址的指针node，分别为cur, first, last, node
       1. cur：迭代器当前所指元素
       2. first：此迭代器所指的缓冲区的头。
       3. last：缓冲区尾。
       4. node：指向管控中心。

### 关联容器

* 关联容器理解？
   1. 关联容器跟顺序容器有着本质上的区别，顺序容器的元素是按照他们在容器的位置进行排序的，关联容器是按照关键字来保存和访问的
   2. 关联容器分为有序关联容器和无序关联容器共八个，他们之间的差异有三点
      1. 容器元素是键值对还是键值
      2. 关键字是否可以重复
      3. 是否按序存储元素
   3. 主要有set和map两个主要的关联容器，map容器的元素是键值对，关键字是索引，一个关键字关联一个值，关键字不能改变但关键字对应的值可以改变；set存放的是键值，每个元素都是唯一的，不能改变，可以快速判断关键字是否在容器中。
   4. 有序关联容器有map,mutilmap,set,mutilmap，他们的底层是用红黑树实现的，可以实现对数复杂度的增删操作，容器的元素是按照键值排序的，其中带用mutil前缀的容器时允许关键字重复
   5. 无序容器：元素的位置无关紧要，唯一重要的是指定的元素是否在集合中，有unorderd_map, unordered_mutil_map,他们的底层是哈希表实现的，由linked list 实现的array，通过哈希函数计算特定元素关键字的哈希值，实现快速访问，哈希表查找特定元素可能快于有序关联容器，是常数复杂度，但缺点是建立哈希表消耗空间大。unordered前缀表示元素无序，mutil表示元素可重复。

* set和multiset的异同？
   1. 异：set和multiset都是根据特定顺序准则自动将元素排序，set不允许元素重复，mutil允许元素重复但由于排序，set中元素无法修改，只能先删除后添加新元素
   2. 同：set和multiset都有序存储元素，底层实现和map一样都是红黑树，插入删除操作可以实现对数复杂度

* 往map中添加元素或删除元素怎么实现的？
   1. 红黑树的增加删除

* 如何实现，查找时间复杂度 能否边遍历边插入
   1. 红黑树 + 散列
   2. 查找时间复杂度是O(lgN)
   3. 不可以边遍历边插入，map不像vector，在对容器erase操作之后不会返回后一个元素迭代器，不能遍历地往后删除

* 为何map/set插入/删除的效率高于其他顺序容器？
   1. 对于关联容器，不需要做内存拷贝和内存移动，map/set的元素是以节点的方式存储，其节点结构和链表相似，指向父节点和子节点

* map为何每次insert之后，以前保存的iterator不会失效?
   1. iterator指向的内存没有改变 指针不会失效。对于vector来说 每一次删除和插入 指针都可能失效， 为了保证内部数据连续存储 iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存被释放

* 为何map和set不能像vector一样有个reserve函数来预分配数据或者重新分配vector容量
   1. map/set储存的已经不是元素本身 而是包含元素的节点 分配器已经发生变化 不是声明时候从参数中传入的alloc，无法reserve

* map和mutilmap的底层数据结构
   1. map/mutilmap是STL的无序关联容器，提供键值对处理能力，mutilmap允许key重复，底层都是红黑树

* unorderd_map和map的区别，使用场景？
   1. unordered_map底层是哈希表，查找时间复杂度为常数，map底层是红黑树，理论上查找平均时间复杂度是指数O(logN);构造unordered_map需要hash函数，map需要比较函数
   2. 使用场景选择因素：查找速度，数据量，内存
      1. 查找速度unordered_map > map，考虑效率则选择unordered_map
      2. 数据量达到一定量级，考虑unorderd_map
      3. 考虑内存消耗，使用map，因为unordered_map底层实哈希表，消耗内存大

* map底层机制
    1. RB树（红黑树），自动排序效果不错，通过map迭代器不能修改其键值，只能修改value

* vector，list ,deque三者的比较
    1. vector自动增长，支持随机查询，速度较快
    2. list擅长插入删除list（可以在任何位置插入元素节点）
    3. deque拥有list vector两者优点的双端队列，支持快速随机访问，无需管理容量，插入元素是动态插入map数组中的缓冲区或者重新建立一个缓冲区
    4. 模板总结:模板都属于序列容器 有共同点 size() begin() end() erase() clear()

* vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择？
    1. vector基于数组，map、multimap基于红黑树，unordered_map，unordered_multimap基于哈希表
    2. 根据应用场景进行选择
       1. map/unordered_map 不允许重复元素
       2. multimap/unordered_multimap 允许重复元素
       3. map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高
       4. unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。

* 容器使用的建议？
    1. level1 仅作为map使用 采用静态数组
    2. level2 保存定长数据  使用时也是全部遍历:采用动态数组
    3. level3 保存不定长数组，需要动态增加的能力，侧重于寻找数据的速度:采用vector
    4. level3 保存不定长数组，需要动态增加的能力，侧重于增加删除数据的速度:采用list
    5. level4 对数据有复杂操作，即需要前后增删数据的能力，又要良好的数据访问速度:采用deque
    6. level5 对数据中间的增删操作比较多:采用list，插入操作O(1) 访问O(N)，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证

* 不允许有遍历行为的容器有哪些（不提供迭代器的）？
    1. queue  stack heap 所有元素必须遵循特别排序规则 不提供遍历功能

* 无序关联容器底层是哈希表，如何避免地址冲突？
    1. 线性探测法:使用hash函数计算某个元素插入位置 若被占用 则继续向前或者向后+1寻找 直到找到一个可用空间
    2. 二次探测法: 如果计算出位置被占用 依次尝试 H + 1^2,  H + 2^2
    3. 链接法: 哈希表中的每一个数组元素中维护一个list链表的首指针，每个元素用hash函数计算哈希值， 当发生冲突时同一哈希值的元素存储到同一list链接起来，然后在list执行插入删除操作

* unorderd_map/unorderd_set的区别？
    1. unorderd_map/unorderd_set底层都是使用了哈希表，没有排序功能，元素可重复
    2. unordered_set存储的是关键字，可以快速查找key，unordered_map存储的是键值对，可以快速查找某个key得到它对应的元素

* unorderd_map与map的区别？
    1. 区别: unorderd_map需要hash函数；map需要比较函数
    2. 存储结构： unordered_map以哈希表为底层 map以RB-Tree为底层
    3. 查找速度：unordered_map查找速度快于map 查找速度和数据量大小无关 属于常数级别  map-lgN unorderd_map有hash函数耗时，考虑效率 元素达到一定级别 用hash_map 考虑内存 元素数量较少 用map

## 面向对象

* 重载和重写的区别
  * 重载
    * 同一个类中函数名相同，但是参数列表的参数数量，类型，顺序的不同的函数称为重载函数，与返回类型无关，
  * 重写
    * 也叫覆盖，子类重新定义父类中有相同名称相同参数的虚函数，主要是在继承关系中出现，在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。
  * 区别
    * 函数的重写和重载都是C++多态的表现，重载是静态多态，在程序编译时根据参数类别确定调用哪个函数，又称为编译时多态。
    * 重写是动态多态，必须是继承关系中，C++通过虚函数实现动态绑定，当子类继承有虚函数的基类，编译器会为该类创建一个虚函数表，所有类对象共用一个虚函数表，子类的重写的函数会覆盖父类的虚函数，子类对象通过一个虚表指针指向虚函数表，运行时将会根据对象的实际类型到虚函数表中调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

* vector的reserve和capacity的区别？
  * reserve(size)用于让容器预留空间，避免再次分配内存,改变capacity但不改变size()；
  * capacity()返回在重新进行分配以前所能容纳的元素数量。

* 什么是多态
  * 多态是面向对象编程的三大特性之一，简单来说就是一个接口，多个方法，用一个父类的指针指向子类对象，当调用方法时，根据父类指针指向的子类类型，动态调用相应子类的函数版本。

  * c++的多态分为两种，一种是静态多态（即编译时多态）
    * 静态多态: 静态多态性是通过重载实现的，在程序编译时系统就可以确定调用哪个函数，因此也称为编译时的多态性
    * 动态多态：通过虚函数实现的，在程序运行时才能决定操作的对象，因此也被称为运行时的多态
    * 运行时多态分析
      * 运行期多态优点
        1. 设计中重要的特性，对客观世界直觉认识。
        2. 能够处理同一个继承体系下的异质类集合。
      * 运行期多态缺点
        1. 运行期间进行虚函数绑定，提高了程序运行开销。
        2. 庞大的类继承层次，对接口的修改易影响类继承层次。
        3. 由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
        4. 虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当值得付出的资源消耗，列为缺点有点勉强。
    * 编译期多态分析
      * 编译期多态优点
        1. 它带来了泛型编程的概念，使得C++拥有泛型编程与STL这样的强大武器。
        2. 在编译器完成多态，提高运行期效率。
        3. 具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
      * 编译期多态缺点
        1. 程序可读性降低，代码调试带来困难。
        2. 无法实现模板的分离编译，当工程很大时，编译时间不可小觑。
        3. 无法处理异质对象集合。

  * c++的多态是通过虚函数和虚函数表实现，子类的函数定义为虚函数，虚函数允许子类对虚函数进行重写（或者叫做覆盖），当子类继承声明了虚函数的父类时，编译器会为子类创建一个虚函数表，在这个表中，记录的是一个子类的虚函数的地址表，每一项是虚函数的函数地址，如果子类覆盖了父类的虚函数，则该项记录的是子类的函数版本，如果没有覆盖则记录的是父类的函数版本，这张表解决了虚函数继承、覆盖的问题
  * 多态的函数地址是晚绑定的，当根据父类指针去调用子类的函数时，根据虚函数表指针到虚函数表中到相应版本的函数地址，从而实现运行时多态。

* 多态的目的
  * 封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。

* c++的多态怎么使用
  * c++的声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了

* 派生类的构造和析构顺序
    1. 先调用父类构 造函数创建父类对象，再调用子类构造函数构造子类对象
    2. 析构顺序与构造顺序相反

* 类成员初始化顺序
  * 基类静态/全局变量 - 子类静态/全局变量 - 基类成员变量 - 子类成员变量

* 什么是虚函数，什么是纯虚函数？
    1. 多态是面向对象编程的三大特点之一，虚函数是实现多态的机制
    2. 虚函数的声明：virtual returntype func(parameter);虚函数是允许被其子类覆盖的成员函数，引入虚函数的目的是为了动态绑定，子类覆盖父类的虚函数后，如果用子类对象调用该函数，会自动调用子类覆盖的函数版本 且函数调用是在运行时才能完成
    3. 纯虚函数声明：virtual returntype func(parameter)=0； 拥有纯虚函数的基类必须要在函数原型后面 = 0 ，只是声明了函数原型，引入纯虚函数是为了派生接口，纯虚函数的类是抽象类，无法生成对象，只能派生,继承抽象类的子类必须实现父类所有的纯虚函数

* 什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
    1. vtbl : 拥有虚函数的子类会有一个或者多个多个虚函数表（一个基类有虚函数就有一个虚函数表），在这个表中，记录的是一个子类的虚函数的地址表，每一项是虚函数的函数地址，如果子类覆盖了父类的虚函数，则该项记录的是子类的函数版本，如果没有覆盖则记录的是父类的函数版本，这张表解决了虚函数继承、覆盖的问题
    2. 同一个类的不同对象都有一个虚函数表指针指向同一个虚函数表，是编译器编译时为创建的，定义类对象时，编译器自动将类对象的虚函数表指针指向整个虚函数表
    3. 虚表的内存布局根据基类和子类的虚函数情况而定，谁有虚函数定义，谁就在前面，多个基类都有虚函数则先继承哪个，哪个的虚函数表在前边

* 为什么虚基类的析构函数必须是虚函数？
    1. 当我们动态申请一个子类对象时，使用基类指针指向子类对象，如果不用虚函数，当销毁子类对象时，只会调用父类的析构函数，子类的析构函数不能得到调用，子类申请的内存不会被释放，所以设置父类的析构函数为虚函数,是为了调用子类的析构函数

* 为什么C++默认的析构函数不是虚函数？
    1. 因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存

* 为什么构造函数不可以是虚函数
  * 从存储空间来说
    * 虚函数对应一个虚函数表，虚函数表指针是存储在对象的内存空间，通过虚函数指针才能访问到虚函数表，从而访问当虚函数，如果构造函数是虚函数，就要通过虚函数表进行调用，但是对象还没初始化，并没有内存空间，无法通过对象的虚函数表指针访问虚函数表，所以构造函数不能是虚函数
  * 从虚函数功能来讲
    * 虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数

* 什么情况下，类的析构函数应该声明为虚函数？为什么？
    1. 基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。
    2. 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

* 访问限定符
  1. public: 允许来自外部的该类对象，子类对象直接访问，或者通过成员函数或者友元函数进行访问，是与类的外部通信的唯一接口
  2. protected:
      1. 受保护的成员不能被类的用户所直接访问
      2. 受保护的成员对于本类和基类的成员函数和友元函数函提供访问权
      3. 派生类的成员或友元函数只能访问派生类对象中从基类继承过来的受保护成员，不能访问基类对象的受保护成员。
  3. private: 只允许本类的友元和成员函数访问

* 定义一个空类编译器做了哪些操作？
  1. 如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符和一个默认析构函数。这些函数只有在第一次被调用时，才会被编译器创建。所有这些函数都是inline和public的

* 继承原理 虚继承 菱形继承 private继承
  1. 菱形继承 A->B A->C  D->B D->C D中有两份拷贝A
  2. 虚继承 : 无论该类在派生层次中作为虚基类出现多少次 只继承一个共享的基类子对象 共享基类子对象称为虚基类
  3. private 继承:
     1. 基类成员对其对象可见: 公有成员可见 其他成员不可见
     2. 基类成员对派生类的可见: 公有成员和保护成员可见 私有成员不可见
     3. 私有继承 基类的成员只能由直接派生类访问 无法再继承

* 菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变量m，m如何在D对象的内存地址上分布的？是否会相互覆盖？
    1. C++虚继承下菱形继承的对象内存布局依赖于编译器。对于vs而言，虚继承通过虚函数表和虚函数表指针（vbptr）实现，子类继承多个基类就有多个对应的虚函数指针表。谁有虚函数谁在前，都有则先继承的基类在前
    2. 如果B,C没有虚继承A基类，则D中有两份成员变量m，可以通过虚拟继承消除二义性，但是虚拟继承的开销是增加虚函数指针。如果B,C虚继承A基类，则B.C类共享一份m成员变量

* 动态绑定与静态绑定
    1. 静态绑定:  call 固定的地址
    2. 动态绑定（编译看父类，运行看子类）: 条件 1.必须通过指针 2.指针可以up_cast 3.调用虚函数 编译器可以做动态绑定形式 编译成 (*(p->vptr)[n])(p);

* this指针：每一个对象都能通过 this 指针来访问自己的地址，用来调用对象的成员函数或者成员变量

* 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？
    1. C++在继承时候 析构函数必须是虚函数 如果不是虚函数可能存在内存泄漏问题，构造函数不能是虚函数
    2. SubClass* pObj = new SubClass();delete pObj;
    3. 不管析构函数是否是虚函数 delete时基类和子类都会被释放
    4. BaseClass* pObj = new SubClass();delete pObj;
    5. 若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放
    6. 若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类；

