# 数据库复盘

## mysql

* 事务的四个特性ACID
  * 原子性
    * 事务是数据库的逻辑工作单位，事务中包含的各个操作要么都做，要么都不做
  * 一致性
    * 事务执行的结果必须使得数据库从一个一致性状态变为另一个一致性状态
  * 隔离性
    * 一个事务的执行不能让其他事务干扰。即一个事务内部的操作和使用的数据对其他并发执行的事务是隔离的，并发执行的各个事务之间是互不干扰的
  * 持续性
    * 也称为永久性，一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的，接下来的其他操作或者故障不应该对其执行结果又任何影响。

* mysql的四种隔离级别，以及它的默认隔离级别
  * Read Uncommitted（读取未提交内容）
    * 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
    * 也被称之为脏读（Dirty Read）
  * Read Committed（读取提交内容）
    * 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变
  * Repeatable Read（可重读）
    * 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
  * Serializable（可串行化）
    * 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

* 什么是幻读？
  * 幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCCMultiversion Concurrency Control）机制解决了该问题。
    * 为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读
    * 并发场景
      * 读-读：不存在任何问题，也不需要并发控制
      * 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读
      * 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
    * 实现
      * 它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的
        * undo日志
          * 回滚用
        * Read View
          * Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

* Mysql的行锁和表锁（ 锁是计算机协调多个进程或纯线程并发访问某一资源的机制）
  * 表级锁： 每次操作锁住整张表。
    * 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低
  * 行级锁： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

* 什么是缓存穿透？如何避免？
  * 缓存穿透
    * 一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,不断地发起请求，当请求量很大时，就会对后端系统造成很大的压力，严重时还会击垮 数据库，这就叫做缓存穿透。
  * 如何避免？
    * 缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接return，比如id做基础校验，id<=0直接拦截。
    * 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
    * 布隆过滤器（Bloom Filter）*这个也能很好的预防缓存穿透的发生，他的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return

* 什么是缓存雪崩？何如避免？
  * 缓存雪崩
    * 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，请求全部落在了数据库上，数据库必然扛不住会给后端系统带来很大压力。严重时导致数据库崩溃。
  * 如何避免？
    * 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
    * 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
    * 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

* 什么是缓存雪崩？何如避免？
  * 缓存击穿
    * 缓存击穿有点像缓存雪崩，但是击穿是指一个key非常热点，在不断地扛着大量的请求时，大并发集中对这个点就行访问，当这个key值在失效的瞬间，持续的大并发请求全部落在了数据库，在key这个点上击穿了缓存。
    * 如何避免
      * 可以设置热点数据永不过期，或者在查询时加上互斥锁。

### mysql的两种引擎

* mysql两种引擎MyISMDB、InnoDB

#### MyISAM

* MyISAM：默认表类型，（5.5版本之前都是默认用它）它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。
  * 不支持事务
  * 不支持外键
  * 支持全文索引
  * 不支持行锁

  * 非聚集索引，但是也是使用B+ tree作为索引结构，索引和文件是分离的，索引保存的是数据文件的指针，直接索引和辅助索引一起使用

  * 如果执行大量的select，insert MyISAM比较适合。
  * 表比较小，或者有大量的select语句

#### InnoDB

* InnoDB：
  * 支持事务安全的引擎，
  * 支持外键
  * 行锁、事务是他的最大特点。
  * 不支持全文索引

  * 聚集索引，使用B+数作为索引结构，数据文件和主键索引绑在一起，必须要有主键，主键索引效率高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据

  * 如果有大量的update和insert，建议使用InnoDB，特别是针对多个并发和QPS较高的情况。（Transaction）功能

* InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

* 使用场景
  * MyISAM更适合读密集的表，而InnoDB更适合写密集的的表
  * 要支持事务，选择innodb,不支持选择mylsam
  * 表中绝大多数都只是读查询，可以考虑MyISAM，既有读也有写，请使用InnoDB
  * 系统奔溃后，MyISAM恢复起来更困难，能否接受
  * MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差

### mysql的索引

* 官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构
  * 查询是数据库的最主要功能之一。我们都希望查询速度能尽可能快，因此数据库系统的设计者会从查询算法角度优化

* MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。
  * 盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。

* 构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。

* B+树是应文件系统所需而产生的一种B树的变形树（文件的目录一级一级索引，只有最底层的叶子节点（文件）保存数据）非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，这不就是文件系统文件的查找吗?
  * 所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的)
  * 非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层
  * 更适合于文件系统

* 分析
  * B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了
  * B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
  * 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

* 分析2
  * 数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。
  * 据库使用B+树肯定是为了提升查找效率。

  * 具体如何提升查找效率呢？
    * 查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。
    * 所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树比较合适。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。

* 主存存取原理
  * 当系统需要读取主存时，将地址信号通过地址总线传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线，供其它部件读取
* 磁盘存取原理
  * 索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O，与主存不同，磁盘I/O存在机械消耗，因此磁盘I/O时间消耗巨大
  * 由于存储介质特性，磁盘本身存取就比主存慢，再加上机械运动耗费，磁盘的存取速度往往是主存的几百万分之一，因此为了提高效率，要尽量减少磁盘I/O。
  * 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用，程序运行期间所需要的数据通常比较集中

* B-/+Tree索引的性能分析
  * 根据B-Tree的定义，可知检索一次最多需要访问h个节点
    * 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载
    * 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O
    * 一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）
    * 用B-Tree作为索引结构效率是非常高
  * 而红黑树，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多
  * B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：
    * 由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。

* 版本
  * 每行数据其实在数据库都是多个版本的，可能同一时间有很多事务在更新一条数据，事务在开始的时候会申请一个id，这个id是严格随着时间递增的，先开始的事务id总是小的，数据库的版本就是事务id的版本。

* MySQL索引实现
  * 索引属于存储引擎级别的概念
  * MyISAM和InnoDB两个存储引擎的索引实现方式
  * MyISAM索引实现
    * MyISAM引擎使用B+Tree作为索引结构，叶节点data域存放数据记录的地址
    * MyISAM的索引文件仅仅保存数据记录的地址
    * 主索引和辅索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅索引的key可以重复
    * MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。
  * InnoDB索引实现
    * InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同
    * MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址
    * 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引
    * 可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引
    * 第二个与MyISAM索引的不同是InnoDB的辅索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域

* 数据库有多少种索引
  * 主键
    * 唯一
    * 普通
    * 全表
    * 主键和普通区别（唯一性、全表只有一个主键索引、主键不为空，主键可作外键）

## redis

* 跳表
  * 跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。
  * 查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。只能从头开始遍历链表，这样效率很低，时间复杂度很高
  * 单链表来说，即使数据是已经排好序的，想要查询其中的一个数据，只能从头开始遍历链表，这样效率很低，时间复杂度很高
  * 跳表用空间换时间
    * 通过存储多层索引，逐层缩小查询返回，提高查询的 效率。

* redis
  * 一个可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库，可以作为缓存和消息中间件等

* 支持的五种数据类型
  * string:字符串，最大512MB
  * hash:适合存储对象
  * list:按照插入顺序排序的列表
    * 底层是用双向链表去实现，可以支持双向查询和遍历，但是带来了额外的开销
    * lpush name:从头添加元素
    * rpush name value: 从尾添加元素
    * lrem name index key :删除count个和value相同的元素
    * llen name：返回key对应vlaue的长度
  * set
    * sadd name value Redis的Set是string类型的无序集合，自动去重，通过hashtable实现的
    * 哈希表实现
  * zset:
    * set 一样也是string类型元素的集合,且不允许重复的成员
    * 不同的是每个元素都会关联一个double类型的分数
    * redis正是通过分数来为集合中的成员进行从小到大的排序
    * zset的成员是唯一的,但分数(score)却可以重复

* redis的zset排序
  * redis正是通过分数来为集合中的成员进行从小到大的排序。实现方式：Redis sorted set的内部使用HashMap和跳跃表(skipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单
  * redis底层用一个reisObject对象表示所有的键值对
    * 数据类型，编码方式，数据指针等

* redis特点
  * 速度快
    * 所有数据都是存放在内存
    * 底层用C语言实现，靠近操作系统，执行效率快
    * redis采用单线程架构，预防了多线程竞争可能产生的问题
  * 采用IO多路服用机制，实现高并发
  * 丰富的数据类型
  * 支持数据持久化
  * 支持主从复制

* c/c++使用redis
  * redis的安装按照REDEME.md文件提示安装就可以了，就可以启用redis-server启动服务端。
  * c/c++主要通过hiredis这个客户端组件提供的c接口函数就可以操作redis
  * 简单的接口函数
    * reisConnect(const char *ip,int port)
      * 该函数用来连接Redis数据库，参数为数据库的ip地址和端口，一般redis数据库的端口为6379
      * 返回要给redis句柄结构体
    * redisCommand(redisCOntext *c,const char      *format,...)操作redis，就像用sql语句一样去操作redis
    * void freeReplyObject(void *reply)释放redisCommand执行后返回的redisReply所占用的内存
    * void redisFree(redisContext *c);释放redisConnect()所

* redis缓存
  * 缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。

* redis雪崩
  * 目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。举个栗子：如果首页所有Key的失效时间都是12小时，中午12点刷新的，我零点有个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能DBA都没反应过来直接挂了，此时，如果没什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。
  * 处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。
    * setRedis（key, value, time+Math.random()*10000）;
  * 如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。

* redis为什么这么快？
  * 所有数据都是存放在内存，直接访问内存，速度较快
    * 底层用C语言实现，c语言的过程式，执行效率快
    * redis采用单线程架构，预防了多线程竞争可能产生的问题（如线程切换，锁机制等），采用epoll多路复用机制去处理高并发。

* redis为什么是单线程的
  * 一位内redis完全基于内存的操作，cpu不是redis的瓶颈，redis的瓶颈可能是机器的内存大小或者网络带宽，考虑到高并发，redis采用io多路复用机制

* redis于memcached区别？
  * 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
  * 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。
  * 使用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
  * value的大小：redis可以达到1GB，而memcache只有1MB。

* redis淘汰策略
  * volatile:从已设置过期时间的键值对集合中选择lru最近最少使用的数据进行淘汰
  * volatile time to live:剩余时间短的数据淘汰
  * volatile random:随机淘汰
  * allkeys-lru:所有的键值对中淘汰
  * allkeys-random
  * noeviction 不淘汰，超过内存则报错
  * redis4.0 加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰

* redis持久化
  * 持久化就是定期把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 Redis 提供了两种持久化
    * 方式:RDB（默认）
      * RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略
      * rdb是Redis DataBase缩写 功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数
      * 默认Redis是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件dump.rdb
      * 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。
      * RDB的优点是：这种文件非常适合用于备份，比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。

* redis持久化
  * 持久化就是定期把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。 Redis 提供了两种持久化
    * 方式:RDB（默认）
      * RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略
      * rdb是Redis DataBase缩写 功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数
      * 默认Redis是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件dump.rdb
      * 当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。
      * RDB的优点是：这种文件非常适合用于备份，比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。
    * AOF
      * 把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。
      * 当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整
      * Append-only file缩写 每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作 aof写入保存：
        * WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件
        * SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。
        * 存储结构: 内容是redis通讯协议(RESP )格式的命令文本存储。比较：aof文件比rdb更新频率高，优先使用aof还原数据。
      * 比较：
        * aof文件比rdb更新频率高，优先使用aof还原数据。
        * aof比rdb更安全也更大
        * rdb性能比aof好

* RDB和AOF应该使用哪个
  * 如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用RDB持久。AOF将Redis执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。数据库备份和灾难恢复：定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度快。当然了，redis支持同时开启RDB和AOF，系统重启后，redis会优先使用AOF来恢复数据，这样丢失的数据会最少。

* redis通讯协议(RESP )
  * RESP 是redis客户端和服务端之前使用的一种通讯协议； RESP 的特点： 实现简单、快速解析、可读性好



#### redis架构

* 单机版
  * 特点：简单
  * 问题：
    * 内存容量有限
    * 处理能力有限
    * 无法高可用
  
* 主从复制
  * Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。 如果主节点挂掉，从节点能继续提供缓存功能，解决了单点故障的问题。
  * 复制流程
    * 1.节点执行slaveof[masterIP][masterPort]，保存主节点信息
    * 2、从节点中的定时任务发现主节点信息，建立和主节点的socket连接
    * 3、从节点发送Ping信号，主节点返回Pong，两边能互相通信
    * 4、连接建立后，主节点将所有数据发送给从节点（数据同步）
    * 5、主节点把当前的数据同步给从节点后，便完成了复制的建立过程
    * 接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。

  * 同步流程
    * redis2.8之前使用sync[runId][offset]同步命令，redis2.8之后使用psync[runId][offset]命令。两者不同在于，sync命令仅支持全量复制过程，psync支持全量和部分复制。介绍同步之前，先介绍几个概念：runId：每个redis节点启动都会生成唯一的uuid，每次redis重启后，runId都会发生变化。offset：主节点和从节点都各自维护自己的主从复制偏移量offset，当主节点有写入命令时，offset=offset+命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点。这样，主节点同时保存自己的offset和从节点的offset，通过对比offset来判断主从节点数据是否一致。repl_backlog_size：保存在主节点上的一个固定长度的先进先出队列，默认大小是1MB。（1）主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。（2）主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救
    * 特点：master/slave 角色
    * master/slave 数据相同
    * 降低 master 读压力在转交从库
    * 问题
      * 无法保证高可用
      * 没有解决 master 写的压力

  * 哨兵
    * redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。
    * 三个特性：
      * 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
      * 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
      * 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。
    * 特点
      * 保证高可用
      * 监控各个节点
      * 自动故障迁移
    * 缺点
      * 主从模式，切换需要时间丢数据
      * 没有解决 master 写的压力

  * 集群（直连型）：
    * 每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。
    * 特点
      * 无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。
      * 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。
      * 可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除
      * 高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本
      * 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。
    * 缺点
      * 资源隔离性较差，容易出现相互影响的情况
      * 数据通过异步复制,不保证数据的强一致性。

#### redis常用命令

* redis常用命令
  * Keys pattern
    * *表示区配所有
  * 以bit开头的
    * 查看Exists  key是否存在
  * Set
    * 设置 key 对应的值为 string 类型的 value
  * setnx
    * 设置 key 对应的值为 string 类型的 value。如果 key 已经存在，返回 0，nx 是 not exist 的意思。
  * 删除某个key
    * 第一次返回1 删除了 第二次返回0
  * Expire 设置过期时间（单位秒）
  * TTL查看剩下多少时间
  * Setex
    * 设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。
  * Mset
    * 一次设置多个 key 的值，成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。
  * Getset
    * 设置 key 的值，并返回 key 的旧值。
  * Mget
    * 一次获取多个 key 的值，如果对应 key 不存在，则对应返回 nil。
  * Incr
    * 对 key 的值做加加操作,并返回新的值。注意 incr 一个不是 int 的 value 会返回错误，incr 一个不存在的 key，则设置 key 为 1
  * incrby
    * 同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0
  * Decr
    * 对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1
  * Decrby
    * 同 decr，减指定值。
  * Append
    * 给指定 key 的字符串值追加 value,返回新字符串值的长度。
  * Strlen
    * 取指定 key 的 value 值的长度。
  * persist xxx(取消过期时间)
    * 选择数据库（0-15库）
  * Select 0 //选择数据库
  * move age 1//把age 移动到1库
  * Randomkey随机返回一个key
  * Rename重命名

* 使用过Redis分布式锁么，它是怎么实现的？
  * 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
* 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
  * set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的

* 使用过Redis做异步队列么，你是怎么用的？有什么缺点？
  * 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
  * 缺点：
    * 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

* 能不能生产一次消费多次呢？
  * 使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

